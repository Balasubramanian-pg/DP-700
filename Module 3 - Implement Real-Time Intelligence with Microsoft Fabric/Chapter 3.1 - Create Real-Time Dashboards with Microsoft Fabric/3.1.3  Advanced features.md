Let me provide a comprehensive expansion on advanced real-time dashboard features, focusing on base queries and multi-page organization strategies that create scalable, maintainable, and user-friendly dashboard experiences.

## Advanced Base Query Patterns

### Hierarchical Base Query Architecture

Base queries form the foundation of efficient dashboard design by centralizing common data processing logic and reducing redundant computations across tiles.

```kql
// Primary base query - foundational data processing
.set base_customer_data = 
customer_transactions
| where ingestion_time() between (ago(2h) .. now())
| extend
    TransactionHour = bin(ingestion_time(), 1h),
    CustomerTier = case(
        TotalSpent > 10000, "Premium",
        TotalSpent > 1000, "Standard", 
        "Basic"
    ),
    RevenueCategory = case(
        TransactionAmount > 500, "High-Value",
        TransactionAmount > 100, "Medium-Value",
        "Low-Value"
    )
| summarize
    latest_transaction = arg_max(ingestion_time(), *),
    transaction_count = count(),
    total_revenue = sum(TransactionAmount),
    avg_transaction_value = avg(TransactionAmount)
    by CustomerId, CustomerTier, TransactionHour;

// Secondary base query - geographic aggregation
.set base_geographic_data =
base_customer_data
| join kind=inner (
    customer_locations
    | project CustomerId, Region, Country, City
) on CustomerId
| summarize
    customer_count = dcount(CustomerId),
    total_revenue = sum(total_revenue),
    avg_customer_value = avg(total_revenue),
    transaction_volume = sum(transaction_count)
    by Region, Country, City, TransactionHour;

// Specialized base query - real-time metrics
.set base_realtime_metrics =
streaming_events
| where ingestion_time() > ago(5min)
| summarize
    events_per_minute = count() / 5.0,
    unique_users = dcount(UserId),
    error_rate = countif(EventType == "Error") * 100.0 / count(),
    avg_response_time = avg(ResponseTimeMs)
    by bin(ingestion_time(), 1min);
```

### Dynamic Base Query Construction

```kql
// Parameterized base query that adapts to user selections
.set-or-replace function CreateDynamicBaseQuery(
    time_window: timespan,
    include_regions: dynamic,
    customer_tiers: dynamic,
    min_transaction_amount: real
) {
    let filtered_data = 
        transaction_stream
        | where ingestion_time() > ago(time_window)
            and (array_length(include_regions) == 0 or Region in (include_regions))
            and (array_length(customer_tiers) == 0 or CustomerTier in (customer_tiers))
            and TransactionAmount >= min_transaction_amount;
    
    filtered_data
    | extend
        TimeGrain = case(
            time_window <= 1h, bin(ingestion_time(), 1m),
            time_window <= 6h, bin(ingestion_time(), 5m),
            time_window <= 24h, bin(ingestion_time(), 15m),
            bin(ingestion_time(), 1h)
        ),
        TransactionCategory = case(
            TransactionAmount > 1000, "Enterprise",
            TransactionAmount > 100, "Business",
            "Consumer"
        )
    | summarize
        transaction_count = count(),
        revenue = sum(TransactionAmount), 
        unique_customers = dcount(CustomerId),
        avg_transaction_size = avg(TransactionAmount),
        latest_activity = max(ingestion_time())
        by TimeGrain, Region, CustomerTier, TransactionCategory
};

// Usage with parameters
.set base_filtered_data = CreateDynamicBaseQuery(
    timespan(['time_range']),
    todynamic(['selected_regions']),
    todynamic(['customer_tiers']),
    toreal(['min_amount'])
);
```

### Performance-Optimized Base Queries

```kql
// Multi-layered base query with performance optimization
.set base_performance_optimized = 
// Layer 1: Fast aggregation for immediate display
let quick_metrics = 
    transaction_summary_1min  // Pre-aggregated materialized view
    | where Timestamp > ago(30min)
    | summarize
        recent_revenue = sum(Revenue),
        recent_transactions = sum(TransactionCount),
        active_customers = sum(UniqueCustomers)
        by bin(Timestamp, 5m);

// Layer 2: Detailed analysis for drill-down capabilities  
let detailed_metrics = 
    iff(['enable_detailed_view'] == "true",
        (
            raw_transactions
            | where ingestion_time() between (ago(30min) .. now())
            | summarize
                revenue = sum(Amount),
                transactions = count(),
                customers = dcount(CustomerId),
                avg_order_value = avg(Amount)
                by bin(ingestion_time(), 1m), ProductCategory, Region
        ),
        (
            print Status = "Detailed view disabled for performance",
                  Action = "Enable detailed view parameter to see granular data"
        )
    );

// Combine layers based on user needs
union 
    (quick_metrics | extend DataType = "Summary"),
    (detailed_metrics | extend DataType = "Detailed");
```

## Advanced Multi-Page Dashboard Architecture

### Logical Page Organization Strategies

#### 1. Executive Overview â†’ Operational Details Pattern

```kql
// Page 1: Executive Dashboard Base Query
.set executive_base_query = 
business_metrics
| where ingestion_time() > ago(24h)
| summarize
    daily_revenue = sum(Revenue),
    daily_orders = sum(OrderCount),
    customer_acquisition = sum(NewCustomers),
    customer_retention_rate = avg(RetentionRate)
    by bin(ingestion_time(), 1h), BusinessUnit
| extend
    revenue_trend = (daily_revenue - prev(daily_revenue)) / prev(daily_revenue) * 100.0,
    growth_indicator = case(
        revenue_trend > 5, "Strong Growth",
        revenue_trend > 0, "Positive Growth",
        revenue_trend > -5, "Stable",
        "Declining"
    );

// Page 2: Operational Dashboard Base Query  
.set operational_base_query =
operational_events
| where ingestion_time() > ago(4h)
| extend
    ServiceLevel = case(
        ResponseTimeMs < 100, "Excellent",
        ResponseTimeMs < 500, "Good", 
        ResponseTimeMs < 2000, "Fair",
        "Poor"
    ),
    ErrorType = case(
        StatusCode >= 500, "Server Error",
        StatusCode >= 400, "Client Error", 
        "Success"
    )
| summarize
    request_count = count(),
    avg_response_time = avg(ResponseTimeMs),
    error_rate = countif(StatusCode >= 400) * 100.0 / count(),
    p95_response_time = percentile(ResponseTimeMs, 95)
    by bin(ingestion_time(), 5min), ServiceName, ErrorType;

// Page 3: Technical Deep-dive Base Query
.set technical_base_query =
system_metrics
| where ingestion_time() > ago(1h)
| summarize
    cpu_utilization = avg(CpuPercent),
    memory_utilization = avg(MemoryPercent), 
    disk_io_ops = sum(DiskIOPS),
    network_throughput = sum(NetworkBytesPerSec)
    by bin(ingestion_time(), 1min), ServerName, ServiceTier;
```

#### 2. Domain-Specific Organization

```kql
// Sales Domain Page Base Query
.set sales_domain_base =
sales_transactions
| where ingestion_time() > ago(6h)
| extend
    SalesChannel = case(
        Channel == "online", "Digital",
        Channel == "retail", "Physical Store",
        Channel == "mobile", "Mobile App",
        "Other"
    ),
    CustomerSegment = case(
        CustomerValue > 5000, "VIP",
        CustomerValue > 1000, "Premium",
        "Standard"
    )
| summarize
    revenue = sum(Amount),
    transactions = count(),
    avg_basket_size = avg(Amount),
    conversion_rate = countif(Status == "Completed") * 100.0 / count()
    by bin(ingestion_time(), 10min), SalesChannel, CustomerSegment, Region;

// Marketing Domain Page Base Query
.set marketing_domain_base =
marketing_events
| where ingestion_time() > ago(12h)
| extend
    CampaignEffectiveness = case(
        ConversionRate > 5, "High Performing",
        ConversionRate > 2, "Moderate",
        "Low Performing"
    ),
    ChannelROI = Revenue / MarketingSpend
| summarize
    impressions = sum(Impressions),
    clicks = sum(Clicks),
    conversions = sum(Conversions),
    marketing_spend = sum(MarketingSpend),
    revenue_attributed = sum(Revenue),
    roi = sum(Revenue) / sum(MarketingSpend)
    by bin(ingestion_time(), 30min), CampaignName, Channel, CampaignEffectiveness;

// Customer Experience Domain Page Base Query
.set cx_domain_base =
customer_interactions
| where ingestion_time() > ago(8h)
| extend
    SatisfactionLevel = case(
        CSAT > 4, "Highly Satisfied",
        CSAT > 3, "Satisfied",
        CSAT > 2, "Neutral", 
        "Dissatisfied"
    ),
    ResolutionEfficiency = case(
        ResolutionTimeMinutes < 5, "Excellent",
        ResolutionTimeMinutes < 15, "Good",
        ResolutionTimeMinutes < 60, "Fair",
        "Poor"
    )
| summarize
    interaction_count = count(),
    avg_satisfaction = avg(CSAT),
    avg_resolution_time = avg(ResolutionTimeMinutes),
    first_contact_resolution = countif(ContactCount == 1) * 100.0 / count()
    by bin(ingestion_time(), 15min), Channel, SatisfactionLevel, ResolutionEfficiency;
```

### Cross-Page Data Consistency and Navigation

```kql
// Shared navigation state management
.set navigation_context = 
dashboard_state
| where StateType == "navigation"
| summarize arg_max(Timestamp, *) by UserId
| project 
    current_page = CurrentPage,
    selected_time_range = TimeRange,
    active_filters = Filters,
    drill_down_context = Context;

// Cross-page filter synchronization
.set synchronized_filters =
let global_filters = toscalar(
    navigation_context 
    | project active_filters 
    | take 1
);

let parsed_filters = todynamic(global_filters);

pack(
    "time_range", tostring(parsed_filters.time_range),
    "regions", todynamic(parsed_filters.regions),
    "business_units", todynamic(parsed_filters.business_units)
);

// Page-specific base query with global context
.set contextual_base_query =
let filters = synchronized_filters;
let time_range = totimespan(filters.time_range);
let regions = todynamic(filters.regions);

transaction_data
| where ingestion_time() > ago(time_range)
    and (array_length(regions) == 0 or Region in (regions))
| extend PageContext = "sales_analysis"
| summarize
    metrics = pack(
        "revenue", sum(Revenue),
        "transactions", count(),
        "customers", dcount(CustomerId)
    ),
    drill_down_data = pack(
        "top_products", take_any(ProductId, 10),
        "peak_hours", take_any(bin(ingestion_time(), 1h), 24)
    )
    by bin(ingestion_time(), 15min), Region;
```

## Advanced Dashboard Composition Patterns

### Responsive Dashboard Layout

```kql
// Adaptive tile sizing based on data volume and complexity
.set adaptive_layout_config =
let data_volume = toscalar(
    base_customer_data 
    | summarize RecordCount = count()
);

let complexity_score = toscalar(
    base_customer_data
    | summarize 
        UniqueRegions = dcount(Region),
        UniqueCustomerTiers = dcount(CustomerTier),
        TimeSpanHours = datetime_diff('hour', max(TransactionHour), min(TransactionHour))
    | extend ComplexityScore = UniqueRegions * UniqueCustomerTiers * TimeSpanHours / 100.0
    | project ComplexityScore
);

pack(
    "recommended_tile_size", case(
        data_volume > 10000 and complexity_score > 50, "large",
        data_volume > 1000 or complexity_score > 10, "medium", 
        "small"
    ),
    "chart_type_recommendation", case(
        complexity_score > 100, "heatmap",
        data_volume > 5000, "aggregated_bar",
        "detailed_line"
    ),
    "refresh_rate_recommendation", case(
        data_volume > 50000, 60,  // 1 minute
        data_volume > 10000, 30,  // 30 seconds
        15  // 15 seconds
    )
);
```

### Interactive Drill-Down Architecture

```kql
// Multi-level drill-down base queries
.set drill_down_level_1 = 
// High-level summary for initial view
base_customer_data
| summarize
    total_revenue = sum(total_revenue),
    customer_count = count(),
    avg_customer_value = avg(total_revenue)
    by Region
| extend DrillDownLevel = 1, 
         NextLevel = "cities_in_region";

.set drill_down_level_2 =
// City-level detail when region is selected
base_geographic_data
| where (isempty(['selected_region']) or Region == ['selected_region'])
| summarize
    total_revenue = sum(total_revenue),
    customer_count = sum(customer_count),
    transaction_volume = sum(transaction_volume)
    by Region, City
| extend DrillDownLevel = 2,
         NextLevel = "customer_segments_in_city";

.set drill_down_level_3 =
// Customer segment detail when city is selected
base_customer_data
| join kind=inner (
    customer_locations
    | where (isempty(['selected_region']) or Region == ['selected_region'])
        and (isempty(['selected_city']) or City == ['selected_city'])
) on CustomerId
| summarize
    revenue = sum(total_revenue),
    customers = count(),
    avg_transaction_size = avg(avg_transaction_value)
    by Region, City, CustomerTier
| extend DrillDownLevel = 3,
         NextLevel = "individual_customers";

// Dynamic drill-down query based on current selection
let current_level = toint(['drill_level']);
case(
    current_level == 1, drill_down_level_1,
    current_level == 2, drill_down_level_2,
    current_level == 3, drill_down_level_3,
    drill_down_level_1  // default to level 1
)
```

### Dashboard Performance Monitoring and Optimization

```kql
// Dashboard performance analytics base query
.set dashboard_performance_base =
let query_performance = 
    .show queries
    | where StartedOn > ago(1h) 
        and Text contains "base_"  // Track base query performance
    | extend
        QueryType = case(
            Text contains "base_customer_data", "Customer Analytics",
            Text contains "base_geographic_data", "Geographic Analysis",
            Text contains "base_realtime_metrics", "Real-time Monitoring",
            "Other"
        ),
        PerformanceCategory = case(
            Duration < 2, "Excellent",
            Duration < 5, "Good",
            Duration < 10, "Fair", 
            "Poor"
        );

let resource_utilization =
    .show cluster-policy capacity
    | extend
        LoadLevel = case(
            UsedCapacity / TotalCapacity > 0.8, "High",
            UsedCapacity / TotalCapacity > 0.6, "Medium",
            "Low"
        );

query_performance
| join kind=cross resource_utilization
| summarize
    query_count = count(),
    avg_duration = avg(Duration),
    p95_duration = percentile(Duration, 95),
    success_rate = countif(State == "Completed") * 100.0 / count()
    by QueryType, PerformanceCategory, LoadLevel
| extend
    optimization_recommendation = case(
        avg_duration > 10, "Consider query optimization or data pre-aggregation",
        success_rate < 95, "Investigate query failures and timeouts",
        LoadLevel == "High", "Consider scaling cluster or optimizing refresh schedules",
        "Performance within acceptable limits"
    );
```

### Advanced Page Navigation and State Management

```kql
// Intelligent page routing based on user behavior and data patterns
.set smart_navigation_base =
let user_activity = 
    dashboard_interactions
    | where ingestion_time() > ago(24h)
        and UserId == ['current_user']
    | summarize
        page_visits = count(),
        avg_time_spent = avg(TimeSpentSeconds),
        most_used_filters = make_set(FilterUsed),
        preferred_time_range = mode(TimeRangeSelected)
        by PageName;

let data_alerts = 
    data_quality_alerts
    | where AlertTime > ago(1h)
    | summarize
        alert_count = count(),
        severity_level = max(Severity)
        by DataDomain;

user_activity
| join kind=fullouter data_alerts on $left.PageName == $right.DataDomain
| extend
    priority_score = case(
        isnotnull(severity_level) and severity_level >= 3, 100,  // Critical alerts
        page_visits * avg_time_spent / 100,  // User engagement score
        0
    ),
    recommended_action = case(
        isnotnull(severity_level) and severity_level >= 3, 
            strcat("Navigate to ", PageName, " - Critical alert requires attention"),
        priority_score > 50,
            strcat("Consider ", PageName, " - High user engagement area"),
        "No specific navigation recommendation"
    )
| order by priority_score desc;
```

This comprehensive approach to base queries and multi-page organization creates highly maintainable, performant, and user-centric real-time dashboards that can scale with organizational needs while providing intuitive navigation and drill-down capabilities.

![Screenshot of a dashboard with multiple pages.](https://learn.microsoft.com/en-us/training/wwl/create-real-time-dashboards-microsoft-fabric/media/dashboard-pages.png)

Let me provide a comprehensive expansion on parameters and auto-refresh functionality in real-time dashboards, covering advanced implementation patterns, best practices, and strategic considerations.

## Advanced Parameter Implementation

### Parameter Types and Use Cases

Parameters in real-time dashboards provide dynamic filtering capabilities that transform static visualizations into interactive analytical tools.

#### Text-Based Parameters

```kql
// Simple text parameter for product search
products
| where contains(ProductName, ['product_search_term'])
| summarize TotalSales = sum(SalesAmount) by ProductCategory
| order by TotalSales desc
```

#### Query-Based Parameters

```kql
// Dynamic parameter based on available data
// Parameter query for regions:
sales_data
| distinct Region
| where isnotempty(Region)
| order by Region asc

// Usage in dashboard query:
sales_data
| where ingestion_time() between (ago(1h) .. now())
    and (isempty(['selected_regions']) or Region in (['selected_regions']))
| summarize 
    TotalRevenue = sum(Revenue),
    OrderCount = count(),
    AvgOrderValue = avg(OrderValue)
    by Region, bin(ingestion_time(), 5m)
```

#### Time-Based Parameters

```kql
// Flexible time range parameter implementation
let start_time = iff(isempty(['time_range']), ago(24h), ago(todatetime(['time_range'])));
let end_time = now();

bike_rentals
| where ingestion_time() between (start_time .. end_time)
    and (isempty(['selected_stations']) or StationName in (['selected_stations']))
| summarize 
    RentalsPerHour = count() / (datetime_diff('hour', end_time, start_time)),
    PeakHour = arg_max(count(), bin(ingestion_time(), 1h))
    by StationName
| order by RentalsPerHour desc
```

### Multi-Level Parameter Dependencies

```kql
// Hierarchical parameter system: Country -> State -> City
// Country parameter query:
locations
| distinct Country
| order by Country asc

// State parameter query (depends on country selection):
locations
| where (isempty(['selected_countries']) or Country in (['selected_countries']))
| distinct State
| order by State asc

// City parameter query (depends on state selection):
locations
| where (isempty(['selected_countries']) or Country in (['selected_countries']))
    and (isempty(['selected_states']) or State in (['selected_states']))
| distinct City
| order by City asc

// Main dashboard query using all parameters:
sales_transactions
| where ingestion_time() between (ago(4h) .. now())
    and (isempty(['selected_countries']) or Country in (['selected_countries']))
    and (isempty(['selected_states']) or State in (['selected_states']))
    and (isempty(['selected_cities']) or City in (['selected_cities']))
| summarize
    Revenue = sum(Amount),
    TransactionCount = count(),
    UniqueCustomers = dcount(CustomerId)
    by bin(ingestion_time(), 10m), Country, State, City
```

### Dynamic Parameter Validation

```kql
// Parameter validation and error handling
let validate_date_range = (start_date: datetime, end_date: datetime) {
    iff(start_date >= end_date, 
        pack("error", "Start date must be before end date"),
        pack("valid", true))
};

let start_param = iff(isempty(['start_date']), ago(7d), todatetime(['start_date']));
let end_param = iff(isempty(['end_date']), now(), todatetime(['end_date']));
let validation = validate_date_range(start_param, end_param);

// Only execute main query if parameters are valid
iff(tobool(validation.valid),
    (
        user_activity
        | where Timestamp between (start_param .. end_param)
            and (isempty(['user_segments']) or UserSegment in (['user_segments']))
        | summarize
            ActiveUsers = dcount(UserId),
            SessionDuration = avg(SessionLengthMinutes),
            PageViews = sum(PageViewCount)
            by bin(Timestamp, 1h), UserSegment
    ),
    (
        print Error = tostring(validation.error)
    )
)
```

## Advanced Auto-Refresh Strategies

### Adaptive Refresh Rates

```kql
// Implement adaptive refresh based on data velocity
let data_velocity = toscalar(
    streaming_events
    | where ingestion_time() > ago(5min)
    | summarize EventsPerMinute = count() / 5.0
);

// Adjust refresh rate based on data volume
let recommended_refresh = 
    iff(data_velocity > 1000, 10,    // 10 seconds for high velocity
    iff(data_velocity > 100, 30,     // 30 seconds for medium velocity  
    iff(data_velocity > 10, 60,      // 1 minute for low velocity
    300)));                          // 5 minutes for very low velocity

// Display recommendation to users
print RecommendedRefreshSeconds = recommended_refresh,
      CurrentDataVelocity = data_velocity,
      Reasoning = case(
          data_velocity > 1000, "High data velocity detected - frequent refresh recommended",
          data_velocity > 100, "Medium data velocity - moderate refresh rate",
          data_velocity > 10, "Low data velocity - standard refresh rate",
          "Very low data velocity - extended refresh interval sufficient"
      )
```

### Conditional Refresh Logic

```kql
// Smart refresh that only updates when meaningful changes occur
let previous_snapshot = toscalar(
    dashboard_snapshots
    | where SnapshotTime > ago(10min)
    | top 1 by SnapshotTime desc
    | project DataHash
);

let current_data_hash = toscalar(
    sales_data
    | where ingestion_time() > ago(30min)
    | summarize TotalRevenue = sum(Revenue)
    | project hash_sha256(tostring(TotalRevenue))
);

// Only refresh if data has meaningfully changed
iff(current_data_hash != previous_snapshot,
    (
        sales_data
        | where ingestion_time() between (ago(30min) .. now())
        | summarize
            Revenue = sum(Revenue),
            Orders = count(),
            AvgOrderValue = avg(OrderValue)
            by bin(ingestion_time(), 1m)
        | extend RefreshReason = "Data changed"
    ),
    (
        print Message = "No significant data changes detected",
              LastRefresh = ago(0s),
              NextCheck = "Will check again in configured interval"
    )
)
```

### Performance-Aware Refresh Management

```kql
// Monitor query performance and adjust refresh accordingly
let query_performance = toscalar(
    .show queries
    | where StartedOn > ago(1h) and Text contains "dashboard_main_query"
    | summarize AvgDuration = avg(Duration)
);

let cluster_load = toscalar(
    .show cluster-policy capacity
    | project UsedCapacity = toint(UsedCapacity), TotalCapacity = toint(TotalCapacity)
    | extend LoadPercentage = (UsedCapacity * 100.0) / TotalCapacity
    | project LoadPercentage
);

// Adaptive refresh based on system performance
let optimal_refresh_rate = 
    iff(cluster_load > 80, 300,      // 5 minutes if cluster is stressed
    iff(query_performance > 10, 120,  // 2 minutes if queries are slow
    iff(query_performance > 5, 60,    // 1 minute for moderate performance
    30)));                           // 30 seconds for good performance

print OptimalRefreshRate = optimal_refresh_rate,
      ClusterLoadPercent = cluster_load,
      AvgQueryDurationSeconds = query_performance,
      PerformanceStatus = case(
          cluster_load > 80, "High cluster load - extending refresh interval",
          query_performance > 10, "Slow query performance - reducing refresh frequency", 
          query_performance > 5, "Moderate performance - standard refresh rate",
          "Good performance - frequent refresh enabled"
      )
```

## Advanced Parameter Patterns

### Complex Filter Combinations

```kql
// Advanced parameter combination with OR/AND logic
let build_filter_clause = (
    include_premium: bool,
    include_standard: bool, 
    min_amount: real,
    exclude_regions: dynamic
) {
    strcat(
        iff(include_premium and include_standard, 
            "", 
            iff(include_premium, "and CustomerTier == 'Premium' ", 
                iff(include_standard, "and CustomerTier == 'Standard' ", "and 1==0 "))),
        iff(min_amount > 0, strcat("and OrderAmount >= ", tostring(min_amount), " "), ""),
        iff(array_length(exclude_regions) > 0, 
            strcat("and Region !in ('", strcat_array(exclude_regions, "','"), "') "), 
            "")
    )
};

// Dynamic query construction
let filter_clause = build_filter_clause(
    tobool(['include_premium']),
    tobool(['include_standard']),
    toreal(['min_order_amount']),
    todynamic(['excluded_regions'])
);

// Execute with dynamic filtering
customer_orders
| where ingestion_time() between (ago(2h) .. now())
| where toscalar(evaluate(strcat("customer_orders | where true ", filter_clause, "| count"))) > 0
| summarize
    TotalRevenue = sum(OrderAmount),
    OrderCount = count(),
    UniqueCustomers = dcount(CustomerId)
    by bin(ingestion_time(), 5m), CustomerTier, Region
```

### Parameter-Driven Visualization Selection

```kql
// Dynamic visualization based on parameter selection
let visualization_type = tostring(['chart_type']);
let time_grain = tostring(['time_granularity']);

let base_data = 
    website_metrics
    | where ingestion_time() between (ago(6h) .. now())
        and (isempty(['selected_pages']) or PageName in (['selected_pages']))
    | extend TimeGrain = case(
        time_grain == "minute", bin(ingestion_time(), 1m),
        time_grain == "5min", bin(ingestion_time(), 5m),
        time_grain == "hour", bin(ingestion_time(), 1h),
        bin(ingestion_time(), 15m)  // default
    );

// Different aggregations based on visualization type
case(
    visualization_type == "trend",
    (
        base_data
        | summarize 
            PageViews = sum(ViewCount),
            UniqueVisitors = dcount(VisitorId)
            by TimeGrain
        | order by TimeGrain asc
    ),
    visualization_type == "breakdown",
    (
        base_data
        | summarize
            PageViews = sum(ViewCount),
            AvgTimeOnPage = avg(TimeOnPageSeconds)
            by PageName
        | order by PageViews desc
    ),
    visualization_type == "heatmap",
    (
        base_data
        | extend Hour = hourofday(ingestion_time()),
                 DayOfWeek = dayofweek(ingestion_time())
        | summarize ActivityScore = sum(ViewCount) by Hour, DayOfWeek
    ),
    // default case
    (
        base_data
        | summarize TotalViews = sum(ViewCount)
        | extend ChartType = "summary"
    )
)
```

## Best Practices and Performance Optimization

### Parameter Query Optimization

```kql
// Efficient parameter query with caching
.set-or-replace function GetDistinctRegions() {
    // Use materialized view or cached result for better performance
    let cached_regions = 
        region_cache
        | where CacheTime > ago(1h)  // Use cache if recent
        | project Region;
    
    let fresh_regions = 
        iff(toscalar(cached_regions | count) > 0,
            cached_regions,
            (
                sales_data
                | where ingestion_time() > ago(7d)  // Only recent data for parameters
                | distinct Region
                | where isnotempty(Region)
            )
        );
    
    fresh_regions | order by Region asc
};

// Usage in parameter definition
GetDistinctRegions()
```

### Resource Management for Auto-Refresh

```kql
// Implement circuit breaker pattern for auto-refresh
let error_rate = toscalar(
    .show queries
    | where StartedOn > ago(15min) 
        and Text contains "dashboard"
        and State == "Failed"
    | summarize ErrorCount = count()
);

let total_queries = toscalar(
    .show queries  
    | where StartedOn > ago(15min)
        and Text contains "dashboard"
    | summarize QueryCount = count()
);

let error_percentage = iff(total_queries > 0, (error_rate * 100.0) / total_queries, 0);

// Circuit breaker logic
iff(error_percentage > 20,  // If error rate > 20%
    (
        print Status = "Circuit breaker activated",
              ErrorRate = error_percentage,
              Action = "Auto-refresh temporarily disabled",
              RecommendedAction = "Check data source connectivity and query logic"
    ),
    (
        // Normal dashboard query execution
        bike_rentals
        | where ingestion_time() between (ago(30min) .. now())
        | summarize
            ActiveRentals = sum(IsActive),
            TotalStations = dcount(StationId),
            AvgRentalsPerStation = count() / dcount(StationId)
            by bin(ingestion_time(), 1m)
    )
)
```

### User Experience Optimization

```kql
// Progressive data loading for better UX
let quick_summary = 
    sales_summary_1min  // Pre-aggregated table for fast loading
    | where Timestamp > ago(2h)
    | summarize 
        Revenue = sum(Revenue),
        Orders = sum(OrderCount)
    | extend LoadTime = "Fast", DataGranularity = "Summary";

let detailed_data = 
    iff(['load_detailed_data'] == "true",
        (
            sales_transactions
            | where ingestion_time() between (ago(2h) .. now())
                and (isempty(['selected_products']) or ProductId in (['selected_products']))
            | summarize
                Revenue = sum(Amount),
                Orders = count(),
                AvgOrderValue = avg(Amount)
                by bin(ingestion_time(), 1m), ProductCategory
            | extend LoadTime = "Detailed", DataGranularity = "Transaction-level"
        ),
        (
            print Message = "Click 'Load Detailed Data' for transaction-level analysis",
                  CurrentView = "Summary view for fast loading"
        )
    );

// Return appropriate dataset based on user preference
union quick_summary, detailed_data
```

## Dashboard Performance Monitoring

```kql
// Monitor dashboard performance metrics
.create-or-alter function MonitorDashboardPerformance() {
    let dashboard_queries = 
        .show queries
        | where StartedOn > ago(1h)
            and Text contains "dashboard"
        | project 
            QueryId = tostring(ClientRequestId),
            StartTime = StartedOn,
            Duration = Duration,
            ResourceUtilization = ResourceUtilization,
            State,
            User;
    
    let performance_metrics = dashboard_queries
        | summarize
            TotalQueries = count(),
            SuccessfulQueries = countif(State == "Completed"),
            FailedQueries = countif(State == "Failed"),
            AvgDurationSeconds = avg(Duration),
            MaxDurationSeconds = max(Duration),
            P95DurationSeconds = percentile(Duration, 95),
            AvgResourceUtilization = avg(ResourceUtilization)
        | extend 
            SuccessRate = (SuccessfulQueries * 100.0) / TotalQueries,
            PerformanceGrade = case(
                AvgDurationSeconds < 2 and SuccessRate > 95, "Excellent",
                AvgDurationSeconds < 5 and SuccessRate > 90, "Good", 
                AvgDurationSeconds < 10 and SuccessRate > 80, "Fair",
                "Needs Improvement"
            );
    
    performance_metrics
    | project 
        Timestamp = now(),
        TotalQueries,
        SuccessRate,
        AvgDurationSeconds,
        P95DurationSeconds,
        PerformanceGrade,
        Recommendations = case(
            AvgDurationSeconds > 10, "Consider query optimization or increasing refresh interval",
            SuccessRate < 90, "Investigate query failures and data source stability",
            AvgResourceUtilization > 80, "Monitor cluster capacity and consider scaling",
            "Performance is within acceptable limits"
        )
};

MonitorDashboardPerformance()
```

This comprehensive approach to parameters and auto-refresh creates dynamic, performant, and user-friendly real-time dashboards that can adapt to varying data conditions and user requirements while maintaining optimal performance and resource utilization.