#### 1. The Primary Advantage of Dynamic Data Masking (DDM)

**✅ Correct Answer: It limits data exposure by obscuring sensitive information in real time.**

*   **Why this is correct:** This is the fundamental purpose of DDM. It acts as a filter on the query results, ensuring that unauthorized users see only a masked version (e.g., `XXX-XX-1234` for a SSN) while the underlying stored data remains unchanged and fully accessible to authorized users and applications.
*   **Key Clarifications:**
    *   **No Data Transformation:** As you noted, the raw data in the table is never altered. Masking is applied on-the-fly at query runtime.
    *   **Minimal Coding:** Policies are defined declaratively on columns (e.g., `ALTER TABLE ALTER COLUMN Phone ADD MASKED WITH (FUNCTION = 'partial(1,"XXX-XX-",4)')`), making it much easier to implement than application-level masking logic.
*   **Real-world Example:** A call center agent might see a customer's masked email (`j***@example.com`) to protect privacy, while a data analyst with explicit permissions would see the full address for analysis.

#### 2. The Purpose of a Security Predicate Function in RLS

**✅ Correct Answer: It determines whether a row is accessible to a user based on certain conditions.**

*   **Why this is correct:** The security predicate is the core logic of RLS. It's an inline table-valued function that the database engine automatically joins to every query against the target table. For each row, it evaluates a condition (e.g., `WHERE UserName = USER_NAME()` or `WHERE SalesRegion = 'West'`) to return a `TRUE` (allow access) or `FALSE` (block access) result.
*   **Key Clarifications:**
    *   **Flexible Logic:** The conditions can be based on user identity, group membership, connection properties, or any other logic you can express in a SQL function.
    *   **Not for Ad Hoc Queries:** RLS doesn't enable or disable ad hoc querying itself; it transparently filters data *within* those queries based on the user's context.

#### 3. The GRANT vs. DENY Precedence

**✅ Correct Answer: The DENY always supersedes the GRANT, and the user is denied access to the specific object.**

*   **Why this is correct:** This is a critical security principle in the Microsoft permission model. `DENY` is an explicit and forceful instruction that overrides any other granted permissions. This provides a crucial safety mechanism to ensure access is definitively blocked, even if a user inherits permissions from multiple roles or groups.
*   **Hierarchy of Permissions:** The standard hierarchy is:
    1.  **DENY** (Explicit Block - Highest Precedence)
    2.  **GRANT** (Explicit Allow)
    3.  **No Permission** (Implicit Deny - Lowest Precedence)
*   **Practical Use Case:** A user might be a member of the "AllEmployees" role, which has `GRANT SELECT` on a salary table. To prevent this user from seeing salaries, you would assign them a "NoSalaryAccess" role that has `DENY SELECT` on that same table. The `DENY` takes precedence.

### Summary: A Layered Security Strategy

These three features are designed to work together as layers in a **defense-in-depth** security strategy for your Fabric data warehouse:

1.  **Row-Level Security (RLS):** Controls **which rows** a user can see. ("You can only see sales data for your own region.")
2.  **Dynamic Data Masking (DDM):** Controls **how specific column values** are displayed, even within rows the user can see. ("You can see the customer's row, but their email will be masked.")
3.  **GRANT/DENY Permissions:** Controls **the fundamental actions** (SELECT, INSERT, etc.) a user can perform on an entire object (table, view). ("You are allowed to query this table.")

Your correct answers demonstrate a strong understanding of how to apply these layers to protect sensitive data effectively. Well done!
