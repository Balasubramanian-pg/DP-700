### What are Dynamic Management Views (DMVs)?

Dynamic Management Views (DMVs) are special "views" in SQL Server and its related technologies (like Microsoft Fabric data warehouses) that provide a **dynamic, real-time snapshot of the internal state of the database engine.** Think of them as built-in monitoring tools that allow you to peek under the hood and see what's currently happening.

They are called "dynamic" because the data they return is not static; it changes constantly as the database engine processes queries, connections are made, sessions are established, and so on.

**Why are DMVs useful?**

DMVs are incredibly valuable for:

- **Performance Monitoring:** Identifying bottlenecks, slow queries, and resource contention.
    
- **Troubleshooting:** Diagnosing issues like blocked processes, deadlocks, and connection problems.
    
- **Capacity Planning:** Understanding resource utilization and predicting future needs.
    
- **Security Auditing:** Monitoring who is connected and what they are doing.
    
- **Debugging:** Gaining insights into the execution plan of queries.
    

You query DMVs just like regular tables using `SELECT` statements. However, they are typically prefixed with `sys.dm_` (or similar) to indicate their special nature.

### Specific Microsoft Fabric Data Warehouse DMVs Explained:

In Microsoft Fabric data warehouses, the DMVs you mentioned focus on connectivity and active work:

1. **`sys.dm_exec_connections`**:
    
    - **What it is:** This DMV provides information about all the **active connections** to your data warehouse.
        
    - **What it tells you:** It's like looking at a list of everyone who is currently "logged in" or has an open connection. For each connection, you'd typically find details such as:
        
        - When the connection was established.
            
        - The authentication method used.
            
        - The client application connecting.
            
        - The network address of the client.
            
        - The connection ID (a unique identifier for that connection).
            
    - **Use Case:** Useful for seeing who is connected to your data warehouse, identifying dormant connections, or understanding the source of connections.
        
2. **`sys.dm_exec_sessions`**:
    
    - **What it is:** This DMV provides information about all the **authenticated sessions** that are currently active in the data warehouse. A session is a logical connection that represents a single user's activity. One connection can have multiple sessions, but typically one session per connection.
        
    - **What it tells you:** It's like seeing each user's active "workspace." For each session, you'd typically find details such as:
        
        - The session ID (a unique identifier for that session).
            
        - The login name of the user.
            
        - The host name from where the connection originated.
            
        - The program name being used.
            
        - When the session started.
            
        - The current status of the session (e.g., sleeping, running).
            
    - **Use Case:** Ideal for identifying which users are active, what applications they are using, and understanding the overall workload on your data warehouse. You can often link sessions back to connections.
        
3. **`sys.dm_exec_requests`**:
    
    - **What it is:** This DMV provides information about all **active requests** (queries or commands) that are currently being executed by the data warehouse.
        
    - **What it tells you:** This is where you see the actual "work" being done. For each request, you'd typically find details such as:
        
        - The session ID that the request belongs to.
            
        - The command type (e.g., `SELECT`, `INSERT`, `UPDATE`).
            
        - The current status of the request (e.g., `running`, `suspended`, `pending`).
            
        - The amount of time the request has been running.
            
        - The wait type if the request is suspended (e.g., waiting for I/O, locks).
            
        - The last wait type.
            
        - The SQL text of the query (often available).
            
        - The plan handle (which can be used to retrieve the query execution plan).
            
    - **Use Case:** This is one of the most powerful DMVs for performance troubleshooting. You can use it to:
        
        - Find long-running queries.
            
        - Identify queries that are blocked or waiting on resources.
            
        - See the actual SQL being executed.
            
        - Monitor resource consumption for active queries.
            

In essence, these three DMVs work together to give you a comprehensive view of who is connected, who is active, and what queries are currently running in your Microsoft Fabric data warehouse, making them indispensable tools for monitoring and management.

![Diagram of dynamic management views.](https://learn.microsoft.com/en-us/training/wwl/monitor-fabric-data-warehouse/media/dynamic-management-views.png)

# Understanding and Using DMVs for Performance Monitoring in SQL Data Warehouse

Dynamic Management Views (DMVs) are powerful tools for monitoring and troubleshooting your SQL data warehouse. The example query you provided is an excellent starting point for analyzing current activity, but let's explore this topic in more depth.

## The Core DMVs in Your Query

Your query combines three key DMVs:

1. **sys.dm_exec_connections**: Shows information about connections to the server
2. **sys.dm_exec_sessions**: Provides details about authenticated sessions
3. **sys.dm_exec_requests**: Contains information about currently executing requests

## Enhanced Version of Your Query

Here's an expanded version with additional useful columns:

```sql
SELECT 
    s.session_id,
    s.login_name,
    s.host_name,
    s.program_name,
    c.client_net_address,
    c.connect_time,
    r.command,
    r.start_time,
    r.status,
    r.wait_type,
    r.wait_time,
    r.last_wait_type,
    r.wait_resource,
    r.total_elapsed_time/1000 as elapsed_seconds,
    r.cpu_time,
    r.logical_reads,
    r.reads,
    r.writes,
    r.granted_query_memory,
    r.blocking_session_id,
    DB_NAME(r.database_id) as database_name,
    r.sql_handle,
    SUBSTRING(qt.text, (r.statement_start_offset/2)+1, 
        ((CASE r.statement_end_offset WHEN -1 THEN DATALENGTH(qt.text) 
          ELSE r.statement_end_offset END - r.statement_start_offset)/2)+1) as executing_statement,
    qt.text as full_query_text
FROM sys.dm_exec_connections AS c
INNER JOIN sys.dm_exec_sessions AS s ON c.session_id = s.session_id
LEFT JOIN sys.dm_exec_requests AS r ON r.session_id = s.session_id
OUTER APPLY sys.dm_exec_sql_text(r.sql_handle) as qt
WHERE r.status = 'running'
    AND r.database_id = DB_ID()
ORDER BY r.total_elapsed_time DESC;
```

## Additional Useful DMVs for Data Warehouse Monitoring

### 1. Query Performance DMVs

```sql
-- Top 10 longest running queries
SELECT TOP 10 
    q.query_id,
    t.query_sql_text,
    q.count_compiles,
    q.avg_compile_time,
    q.avg_duration,
    q.avg_cpu_time,
    q.avg_logical_io_reads,
    q.avg_rowcount
FROM sys.query_store_query q
JOIN sys.query_store_query_text t ON q.query_text_id = t.query_text_id
ORDER BY q.avg_duration DESC;
```

### 2. Resource Utilization DMVs

```sql
-- Resource class utilization
SELECT 
    rc.name as resource_class,
    COUNT(*) as active_queries,
    SUM(r.granted_query_memory) as total_memory_grant
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
JOIN sys.dm_workload_management_workload_groups_stats rc 
    ON s.group_id = rc.group_id
WHERE r.status = 'running'
GROUP BY rc.name;
```

### 3. TempDB Usage

```sql
-- TempDB usage by session
SELECT 
    s.session_id,
    s.login_name,
    SUM(u.user_objects_alloc_page_count) * 8 as user_objects_kb,
    SUM(u.internal_objects_alloc_page_count) * 8 as internal_objects_kb
FROM sys.dm_db_session_space_usage u
JOIN sys.dm_exec_sessions s ON u.session_id = s.session_id
GROUP BY s.session_id, s.login_name
ORDER BY (SUM(u.user_objects_alloc_page_count) + SUM(u.internal_objects_alloc_page_count)) DESC;
```

## Practical Use Cases

1. **Identifying Blocking Issues**:
   ```sql
   SELECT 
       blocking.session_id as blocking_session_id,
       blocked.session_id as blocked_session_id,
       blocked.wait_type,
       blocked.wait_time,
       blocked.wait_resource,
       DB_NAME(blocked.database_id) as database_name
   FROM sys.dm_exec_requests blocked
   JOIN sys.dm_exec_sessions blocking ON blocked.blocking_session_id = blocking.session_id
   WHERE blocked.blocking_session_id <> 0;
   ```

2. **Monitoring Data Movement Operations**:
   ```sql
   SELECT 
       s.session_id,
       s.login_name,
       r.command,
       r.start_time,
       r.status,
       r.wait_type,
       r.total_elapsed_time/1000 as elapsed_seconds,
       dm.move_type,
       dm.rows_processed,
       dm.bytes_processed/1024/1024 as mb_processed
   FROM sys.dm_exec_requests r
   JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
   JOIN sys.dm_pdw_dms_workers dm ON r.session_id = dm.pdw_node_id
   WHERE r.status = 'running'
   ORDER BY r.total_elapsed_time DESC;
   ```

3. **Analyzing Memory Grants**:
   ```sql
   SELECT 
       session_id,
       request_id,
       requested_memory_kb/1024 as requested_memory_mb,
       granted_memory_kb/1024 as granted_memory_mb,
       used_memory_kb/1024 as used_memory_mb,
       max_used_memory_kb/1024 as max_used_memory_mb
   FROM sys.dm_exec_query_memory_grants
   ORDER BY requested_memory_kb DESC;
   ```

## Best Practices for DMV Usage

1. **Filter your results** - DMVs often return large datasets, so always include appropriate WHERE clauses
2. **Consider time windows** - For historical analysis, use Query Store instead of DMVs
3. **Be mindful of overhead** - Some DMVs can be resource-intensive to query
4. **Combine with other tools** - Use DMVs alongside Azure Monitor, Log Analytics, and other monitoring tools
5. **Regularly collect snapshots** - For trend analysis, periodically capture DMV data

These expanded DMV queries will give you much deeper insight into your data warehouse's performance characteristics and help identify optimization opportunities.

|session_id|login_name|client_net_address|command|start_time|total_elapsed_time|
|---|---|---|---|---|---|
|60|fred@contoso.com|10.23.139.162|SELECT|2023-12-07T14:56:41.3530000|57266|
|126|nandita@contoso.com|10.23.137.98|SELECT|2023-12-07T14:57:22.7800000|15840|
|137|zoe@contoso.com|10.23.119.171|SELECT|2023-12-07T14:57:38.6070000|4|


> [!NOTE]
> For more information about using DMVs, refer to **[Monitor connections, sessions, and requests using DMVs](https://learn.microsoft.com/en-us/fabric/data-warehouse/monitor-using-dmv)** in the Microsoft Fabric documentation.