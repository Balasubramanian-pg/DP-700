
# Optimizing KQL Queries in Eventhouse: Column Filtering Best Practices

## The Importance of Column Filtering in Eventhouse

When working with KQL databases in eventhouses, proper column filtering is crucial because:

1. **Volume Handling**: Eventhouses process massive streams of real-time data
2. **Performance**: Reducing data volume improves query speed
3. **Cost Efficiency**: Processes fewer bytes, lowering compute resources
4. **Result Clarity**: Returns only relevant data to consumers

## The `project` Operator Explained

The `project` operator is KQL's equivalent to SQL's `SELECT` column list but with important differences in behavior and optimization:

### Basic Syntax
```kql
TableName
| project column1, column2, calculated_column = expression
```

### Example with Automotive Data
```kql
Automotive
| project trip_id, vendor_id, pickup_datetime, fare_amount
```

## Why This Matters for Performance

1. **Early Reduction Principle**:
   - Applies column filtering early in the execution pipeline
   - Subsequent operations work with less data

2. **Memory Optimization**:
   - Only selected columns are loaded into memory
   - Particularly important for wide tables with many columns

3. **Network Efficiency**:
   - Reduces data transferred between nodes in distributed systems

## Advanced `project` Techniques

### 1. Column Renaming
```kql
Automotive
| project 
    TripIdentifier = trip_id, 
    Company = vendor_id, 
    PickupTime = pickup_datetime,
    Fare = fare_amount
```

### 2. Calculated Columns
```kql
Automotive
| project 
    trip_id,
    pickup_datetime,
    fare_amount,
    fare_with_tax = fare_amount * 1.08,
    is_peak_hour = case(hour_of_day(pickup_datetime) between (7..9) or (16..18), "Yes", "No")
```

### 3. Conditional Column Inclusion
```kql
Automotive
| project 
    trip_id,
    pickup_datetime,
    fare_amount,
    iff(has_columns("toll_amount"), toll_amount, real(0)) as toll_amount
```

## When to Apply `project`

1. **Early in Query**:
   ```kql
   Automotive
   | project trip_id, vendor_id, pickup_datetime, fare_amount
   | where fare_amount > 20
   ```

2. **After Initial Filtering** (when early filtering significantly reduces rows):
   ```kql
   Automotive
   | where pickup_datetime > ago(1h)
   | project trip_id, vendor_id, pickup_datetime, fare_amount
   ```

## Comparison with SQL

### KQL
```kql
Automotive
| project trip_id, vendor_id, pickup_datetime, fare_amount
```

### SQL
```sql
SELECT trip_id, vendor_id, pickup_datetime, fare_amount
FROM Automotive
```

**Key Difference**: KQL's `project` is more than just column selection - it's a pipeline operator that transforms the data stream.

## Performance Impact Tests

Consider a table with:
- 50 columns
- 10 million rows
- Average row size of 2KB

| Query Approach | Data Processed | Execution Time |
|---------------|----------------|----------------|
| No `project`  | ~100GB         | 45 seconds     |
| With `project` (4 cols) | ~8GB | 6 seconds |

## Best Practices

1. **Always specify columns** rather than using wildcards
2. **Place `project` early** in the query when possible
3. **Combine with other optimizations**:
   ```kql
   Automotive
   | where pickup_datetime > ago(1d)  // Time filter first
   | project trip_id, vendor_id, pickup_datetime, fare_amount
   | where fare_amount > 20  // Then other filters
   ```
4. **Review query plans** to ensure `project` pushes down properly

## Common Pitfalls to Avoid

1. **Projecting too late**:
   ```kql
   // Less optimal
   Automotive
   | where fare_amount > 20
   | summarize count() by vendor_id
   | project vendor_id, count_
   ```

2. **Unnecessary columns**:
   ```kql
   // Bad - includes unused column
   Automotive
   | project trip_id, vendor_id, pickup_datetime, fare_amount, unused_column
   ```

3. **Over-calculating**:
   ```kql
   // Calculations before projection waste resources
   Automotive
   | extend calculated_value = fare_amount * 1.08
   | project trip_id, calculated_value
   ```

By following these column filtering best practices with the `project` operator, you'll achieve significantly better performance in your Eventhouse KQL queries while working with real-time data streams.

---
# Advanced Row Filtering Techniques in KQL for Eventhouse

## Temporal Filtering Best Practices

### 1. Current Month Filtering (Improved Version)
```kql
Automotive
| where startofmonth(now()) <= pickup_datetime and pickup_datetime < startofmonth(now(), 1)
| project trip_id, vendor_id, pickup_datetime, fare_amount
```

**Why better?**
- Uses single range comparison instead of separate month/year checks
- `startofmonth()` is more precise than `getmonth()`/`getyear()` combinations
- Handles timezone considerations automatically

### 2. Relative Time Filtering (Enhanced Options)
```kql
// Last 30 minutes (standard)
Automotive
| where pickup_datetime > ago(30min)

// Time range between two relative points
Automotive
| where pickup_datetime between (ago(2h) .. ago(1h))

// Dynamic time windows
let lookbackPeriod = 45min;
Automotive
| where pickup_datetime > ago(lookbackPeriod)
```

## Ingestion Time vs. Event Time

### Key Differences:
|                      | `ingestion_time()`               | Event Time (e.g., `pickup_datetime`) |
|----------------------|----------------------------------|--------------------------------------|
| Source               | When Eventhouse received the data | When the event actually occurred     |
| Use Case             | Pipeline monitoring              | Event analysis                       |
| Consistency          | Always available                 | Requires timestamp in data           |
| Typical Filters      | `ago()`, `between`               | `startofday()`, `bin()`              |

### Advanced Ingestion Time Example
```kql
Automotive
| where ingestion_time() between (ago(3h) .. ago(1h))
| summarize 
    TotalTrips = count(),
    MaxLatency = max(ingestion_time() - pickup_datetime)
    by vendor_id
| order by MaxLatency desc
```

## Performance-Optimized Filtering Techniques

### 1. Compound Conditions
```kql
Automotive
| where 
    pickup_datetime > ago(6h) and
    fare_amount between (20 .. 100) and
    trip_distance > 5 and
    vendor_id in ("Uber", "Lyft")
| project trip_id, vendor_id, pickup_datetime, fare_amount
```

### 2. Time-Based Partition Pruning
```kql
Automotive
| where pickup_datetime >= datetime(2023-11-01) and pickup_datetime < datetime(2023-12-01)
```

### 3. Dynamic Threshold Filtering
```kql
let min_fare = 25.0;
let max_distance = 15.0;
Automotive
| where 
    fare_amount > min_fare and
    trip_distance < max_distance and
    pickup_datetime > ago(8h)
```

## Specialized Temporal Functions

### 1. Time Binning
```kql
Automotive
| where pickup_datetime > ago(1d)
| summarize 
    AverageFare = avg(fare_amount), 
    TripCount = count()
    by 
    vendor_id,
    bin(pickup_datetime, 1h)
| order by pickup_datetime asc
```

### 2. Day-of-Week Filtering
```kql
Automotive
| where dayofweek(pickup_datetime) between (1 .. 5)  // Weekdays only
| where hourofday(pickup_datetime) between (7 .. 9)  // Morning rush hour
```

### 3. Timezone-Aware Filtering
```kql
Automotive
| where datetime_utc_to_local(pickup_datetime, "US/Eastern") 
      between (startofday(now(), "US/Eastern") .. now())
```

## Filter Optimization Tips

1. **Order Matters**: Place most restrictive filters first
   ```kql
   // Better
   | where fare_amount > 100
   | where trip_distance < 2

   // Less optimal
   | where trip_distance < 2
   | where fare_amount > 100
   ```

2. **Avoid Functions on Filtered Columns**: 
   ```kql
   // Less optimal
   | where getmonth(pickup_datetime) == 11

   // Better
   | where pickup_datetime between (datetime(2023-11-01) .. datetime(2023-12-01))
   ```

3. **Use Materialized Views**: For frequently filtered columns
   ```kql
   .create materialized-view AutomotiveByVendor on table Automotive
   {
       Automotive
       | summarize by vendor_id, bin(pickup_datetime, 1h)
   }
   ```

These techniques ensure your Eventhouse queries remain performant even with high-velocity streaming data while providing precise temporal filtering capabilities.

---
# Data Summarization in KQL for Eventhouse

## Understanding Data Summarization

Summarization is a powerful technique in KQL that transforms high-volume event data into meaningful aggregates, enabling pattern analysis while reducing data volume. Here's a deep dive into the example query and its applications:

## The Example Query Explained

```kql
Automotive
| where ingestion_time() > ago(1d)
| summarize average_fare = avg(fare_amount) by vendor_id, pickup_hour = hourofday(pickup_datetime)
| project pickup_hour, vendor_id, average_fare
| sort by pickup_hour
```

### Breakdown:
1. **Time Filtering**: `where ingestion_time() > ago(1d)` - Focuses on recent data
2. **Aggregation**: `summarize` with:
   - Calculation: `average_fare = avg(fare_amount)`
   - Grouping: `by vendor_id, pickup_hour`
3. **Time Extraction**: `hourofday()` function extracts hour component
4. **Projection**: Selects only relevant output columns
5. **Sorting**: Orders results chronologically

## Key Aggregation Functions

KQL provides numerous aggregation functions for summarization:

| Function | Example | Description |
|----------|---------|-------------|
| `count()` | `summarize trips=count()` | Count of events |
| `avg()` | `avg(fare_amount)` | Arithmetic mean |
| `sum()` | `sum(fare_amount)` | Total sum |
| `min()`/`max()` | `max(trip_distance)` | Extremes |
| `percentiles()` | `percentiles(fare_amount, 50, 95)` | Statistical percentiles |
| `dcount()` | `dcount(trip_id)` | Distinct count |
| `stdev()` | `stdev(fare_amount)` | Standard deviation |

## Advanced Summarization Techniques

### 1. Multi-Level Time Grouping
```kql
Automotive
| summarize 
    avg_fare = avg(fare_amount),
    trip_count = count()
    by 
    vendor_id,
    day = startofday(pickup_datetime),
    hour = bin(pickup_datetime, 1h)
```

### 2. Conditional Aggregations
```kql
Automotive
| summarize 
    total_fares = sum(fare_amount),
    credit_card_payments = sumif(fare_amount, payment_type == "Credit"),
    avg_long_trip_fare = avgif(fare_amount, trip_distance > 10)
    by vendor_id
```

### 3. Time Series Patterns
```kql
Automotive
| make-series avg_fare=avg(fare_amount) default=0
    on pickup_datetime from ago(7d) to now() step 1h
    by vendor_id
| render timechart
```

## Practical Applications

1. **Performance Monitoring**:
```kql
Automotive
| summarize 
    p95_fare = percentiles(fare_amount, 95),
    avg_duration = avg(dropoff_datetime - pickup_datetime)
    by vendor_id, bin(pickup_datetime, 1h)
```

2. **Anomaly Detection**:
```kql
let normalRange = 
    Automotive
    | where pickup_datetime between (ago(30d) .. ago(1d))
    | summarize 
        avg_fare = avg(fare_amount),
        stdev_fare = stdev(fare_amount)
        by vendor_id, hourofday(pickup_datetime);

Automotive
| where pickup_datetime > ago(1d)
| join kind=inner normalRange on vendor_id, $left.hourofday(pickup_datetime) == $right.hourofday
| extend z_score = (fare_amount - avg_fare)/stdev_fare
| where abs(z_score) > 3
```

## Optimization Tips

1. **Filter Early**: Apply time filters before summarization
2. **Limit Grouping**: Only group by necessary dimensions
3. **Use Approximations**: For large datasets, consider:
   ```kql
   | summarize dcount_hll(trip_id) by vendor_id
   ```
4. **Materialized Views**: For frequent aggregations:
   ```kql
   .create materialized-view DailyVendorStats on table Automotive {
       Automotive
       | summarize 
           trip_count = count(),
           total_fares = sum(fare_amount)
           by vendor_id, bin(pickup_datetime, 1d)
   }
   ```

## Visualization Integration

Summarized data works well with KQL's visualization capabilities:
```kql
Automotive
| summarize avg_fare = avg(fare_amount) 
    by vendor_id, bin(pickup_datetime, 1h)
| render timechart with (title="Hourly Fare Trends")
```

This approach enables efficient analysis of streaming data while maintaining the ability to identify meaningful patterns and trends.

---