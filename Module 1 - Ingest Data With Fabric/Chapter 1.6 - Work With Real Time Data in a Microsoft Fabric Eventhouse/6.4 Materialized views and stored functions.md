While you can often achieve your analytical goals by querying tables and using built-in functions and operators, KQL provides some advanced features that you can use to create new objects that encapsulate data or logic that you frequently need to use.

# Mastering Materialized Views in KQL for Eventhouse

Materialized views are a powerful performance optimization feature in KQL that pre-compute and store aggregated data, enabling faster query performance for common analytical patterns.

## Core Concepts of Materialized Views

### What They Do:
- **Pre-compute aggregations** from source tables
- **Automatically update** as new data arrives
- **Persist results** for fast retrieval
- **Reduce compute costs** for frequent queries

### Your Example Explained:
```kql
.create materialized-view TripsByVendor on table Automotive
{
    Automotive
    | summarize trips = count() by vendor_id, pickup_date = format_datetime(pickup_datetime, "yyyy-MM-dd")
}
```

**Key Components:**
- `TripsByVendor`: View name
- `on table Automotive`: Source table
- `summarize`: Aggregation logic
- `by vendor_id, pickup_date`: Grouping dimensions

## Advanced Creation Options

### 1. Backfilling Existing Data
```kql
.create async materialized-view with (backfill=true)
TripsByVendor on table Automotive
{
    Automotive
    | summarize trips = count() 
    by vendor_id, pickup_date = format_datetime(pickup_datetime, "yyyy-MM-dd")
}
```

**Why Async?**
- Prevents blocking during large backfills
- Progress can be monitored
- Better for production environments

### 2. Retention Policies
```kql
.create materialized-view with (backfill=true, retention=30d)
RecentTripsByVendor on table Automotive
{
    Automotive
    | where pickup_datetime > ago(30d)
    | summarize trips = count() by vendor_id, bin(pickup_datetime, 1d)
}
```

### 3. Partitioned Views
```kql
.create materialized-view with (backfill=true, partitioned=true)
PartitionedTrips on table Automotive
{
    Automotive
    | summarize trips = count()
    by vendor_id, pickup_date = format_datetime(pickup_datetime, "yyyy-MM-dd")
}
```

## Querying Materialized Views

### Basic Query:
```kql
TripsByVendor
| project pickup_date, vendor_id, trips
| sort by pickup_date desc
```

### Advanced Patterns:

1. **Joining with Source Data**:
```kql
TripsByVendor
| join kind=inner Automotive on vendor_id
| where pickup_datetime between (ago(7d) .. now())
```

2. **Time Series Analysis**:
```kql
TripsByVendor
| make-series trips=sum(trips) on pickup_date from ago(30d) to now() step 1d
    by vendor_id
| render timechart
```

3. **Rolling Aggregations**:
```kql
TripsByVendor
| summarize 
    weekly_trips = sum(trips),
    avg_daily = avg(trips)
    by vendor_id, week = startofweek(pickup_date)
```

## Management Commands

### View All Materialized Views:
```kql
.show materialized-views
```

### View Details:
```kql
.show materialized-view TripsByVendor
```

### Monitor Backfill Progress:
```kql
.show operations
| where Operation == "MaterializedViewCreate"
```

### Drop a View:
```kql
.drop materialized-view TripsByVendor
```

## Performance Considerations

1. **Incremental Processing**: Only new data is processed
2. **Storage Overhead**: Views consume additional storage
3. **Update Latency**: Near real-time but not instantaneous
4. **Query Optimization**: Query engine automatically uses views when beneficial

## Best Practices

1. **Target Frequent Aggregations**: Focus on queries run repeatedly
2. **Balance Granularity**: Not too detailed (storage costs) nor too coarse (useless)
3. **Monitor Usage**:
```kql
.show materialized-view-usage
| where ViewName == "TripsByVendor"
```
4. **Combine with Functions**:
```kql
.create-or-alter function get_vendor_stats()
{
    TripsByVendor
    | summarize total_trips = sum(trips) by vendor_id
}
```

## Real-World Example

```kql
.create async materialized-view with (backfill=true, retention=90d)
VendorPerformance on table Automotive
{
    Automotive
    | summarize 
        trips = count(),
        total_fares = sum(fare_amount),
        avg_fare = avg(fare_amount),
        p95_fare = percentiles(fare_amount, 95)
    by 
        vendor_id, 
        pickup_date = format_datetime(pickup_datetime, "yyyy-MM-dd"),
        hour_of_day = hourofday(pickup_datetime)
}
```

This comprehensive view enables fast analysis of vendor performance across multiple dimensions while automatically staying up-to-date as new trip data arrives.

---

# Mastering Stored Functions in KQL for Eventhouse

Stored functions are a powerful feature in KQL that enable code reuse, simplify complex queries, and improve maintainability. Let's explore this capability in depth.

## Creating Stored Functions

### Basic Syntax
```kql
.create-or-alter function function_name(parameter:type, ...)
{
    // KQL query body
    // Reference parameters directly
}
```

### Your Example Explained
```kql
.create-or-alter function trips_by_min_passenger_count(num_passengers:long)
{
    Automotive
    | where passenger_count >= num_passengers 
    | project trip_id, pickup_datetime
}
```

**Key Points:**
- `create-or-alter` creates new or updates existing functions
- Strong typing for parameters (`long` in this case)
- Function body contains standard KQL operators
- Parameters are referenced directly in the query

## Advanced Function Features

### 1. Multiple Parameters
```kql
.create-or-alter function trips_by_fare_range(min_fare:real, max_fare:real)
{
    Automotive
    | where fare_amount between (min_fare .. max_fare)
    | project trip_id, pickup_datetime, fare_amount
}
```

### 2. Default Parameter Values
```kql
.create-or-alter function recent_trips(lookback:timespan = 1h)
{
    Automotive
    | where pickup_datetime > ago(lookback)
}
```

### 3. Complex Function Logic
```kql
.create-or-alter function high_value_trips(min_fare:real = 50.0, min_distance:real = 10.0)
{
    Automotive
    | where fare_amount >= min_fare and trip_distance >= min_distance
    | extend fare_per_mile = fare_amount / trip_distance
    | project-away passenger_count  // Explicitly remove columns
}
```

## Function Management Commands

### View All Functions
```kql
.show functions
```

### View Function Definition
```kql
.show function trips_by_min_passenger_count
```

### Delete Function
```kql
.drop function trips_by_min_passenger_count
```

## Practical Use Cases

### 1. Standardized Business Metrics
```kql
.create-or-alter function revenue_by_vendor(period:timespan = 1d)
{
    Automotive
    | where pickup_datetime > ago(period)
    | summarize total_revenue = sum(fare_amount) by vendor_id
    | order by total_revenue desc
}
```

### 2. Parameterized Analytics
```kql
.create-or-alter function fare_percentiles(percentiles:dynamic = dynamic([25, 50, 75]))
{
    Automotive
    | summarize percentiles(fare_amount, percentiles)
}
```

### 3. Data Quality Checks
```kql
.create-or-alter function validate_timestamps(max_future:timespan = 5m)
{
    Automotive
    | where pickup_datetime > now() + max_future  // Future timestamps
    | count
}
```

## Performance Considerations

1. **Function Inlining**: KQL optimizes by inlining function code
2. **Parameter Sniffing**: Functions use parameter values for optimization
3. **Materialized Views**: Combine with functions for better performance
   ```kql
   .create materialized-view HighValueTrips on table Automotive
   {
       high_value_trips(40.0, 8.0)  // Using our previously defined function
   }
   ```

## Best Practices

1. **Descriptive Names**: Use clear function names like `get_weekly_revenue_trends`
2. **Parameter Validation**: Add checks for valid parameter ranges
   ```kql
   .create-or-alter function safe_trips_by_passengers(num_passengers:long)
   {
       Automotive
       | where num_passengers > 0 and num_passengers < 10  // Validation
       | where passenger_count >= num_passengers
   }
   ```
3. **Documentation**: Add comments explaining purpose and parameters
4. **Version Control**: Track function changes outside the database

## Calling Functions

### Basic Call
```kql
trips_by_min_passenger_count(3)
| take 10
```

### In Complex Queries
```kql
high_value_trips(75.0, 15.0)
| summarize avg_fare = avg(fare_amount) by vendor_id
| join kind=inner (revenue_by_vendor(7d)) on vendor_id
```

Stored functions significantly enhance KQL's capabilities in Eventhouse, enabling you to build reusable analytics components that can be shared across teams and projects.