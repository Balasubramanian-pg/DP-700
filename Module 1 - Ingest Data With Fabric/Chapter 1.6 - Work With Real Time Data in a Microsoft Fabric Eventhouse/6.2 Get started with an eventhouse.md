To create an eventhouse, you must be working on a workspace with a Fabric capacity that supports the Real-Time Intelligence Fabric capability. You can then create one or more eventhouses for your data.

![Screenshot of an eventhouse in Microsoft Fabric.](https://learn.microsoft.com/en-us/training/wwl/query-data-kql-database-microsoft-fabric/media/eventhouse.png)

An eventhouse contains one or more KQL databases, in which you can create tables, stored procedures, materialized views, and other items to manage your data. After creating an eventhouse, you can use the default KQL database or create a new one.

To get your data into a KQL database in an eventhouse, you typically import it from a static location (such as a local file, OneLake, Azure storage, or a sample dataset) or from a real-time source (such as Azure Event Hubs or a Fabric eventstream).

![Screenshot of the Get Data menu for an eventhouse in Microsoft Fabric.](https://learn.microsoft.com/en-us/training/wwl/query-data-kql-database-microsoft-fabric/media/get-data.png)

> [!NOTE]
> You can enable the **OneLake** option for a database or for individual tables it contains, making the data from these tables available in OneLake.

# Querying Tables in a KQL Database (Eventhouse)

## Basic Query Structure

Kusto Query Language (KQL) provides an intuitive way to query data in Eventhouse tables. Here's a comprehensive explanation of querying fundamentals:

## 1. Basic Table Query

### KQL
```kql
Automotive
```

### SQL Equivalent
```sql
SELECT * FROM Automotive
```

**Key Points:**
- Simplest possible query that returns all columns and rows
- Rarely used in production with streaming data due to volume
- Useful for quick table inspection during development

## 2. Sampling Data with `take`

### KQL
```kql
Automotive
| take 100
```

### SQL Equivalent
```sql
SELECT TOP 100 * FROM Automotive
```

**Key Differences:**
- KQL uses pipeline operator `|` to chain operations
- `take` is non-deterministic (random 100 rows) unless sorted first
- In streaming contexts, returns most recent 100 records by default

## 3. Selecting Specific Columns

### KQL
```kql
Automotive
| project trip_id, pickup_datetime, fare_amount
```

### SQL Equivalent
```sql
SELECT trip_id, pickup_datetime, fare_amount 
FROM Automotive
```

**Performance Considerations:**
- `project` reduces data volume early in the pipeline
- More efficient than selecting all columns first then filtering
- Can include calculated columns: `| project trip_id, fare_amount, double_fare = fare_amount * 2`

## 4. Filtering Rows

### KQL
```kql
Automotive
| where fare_amount > 20
| project trip_id, pickup_datetime, fare_amount
```

### SQL Equivalent
```sql
SELECT trip_id, pickup_datetime, fare_amount
FROM Automotive 
WHERE fare_amount > 20
```

**Optimization Tips:**
- Apply `where` before `project` when possible
- Time-based filters are particularly efficient: `| where pickup_datetime > ago(7d)`
- Supports complex conditions: `| where fare_amount > 20 and trip_distance < 10`

## 5. Sorting Results

### KQL
```kql
Automotive
| where fare_amount > 20
| project trip_id, pickup_datetime, fare_amount
| sort by pickup_datetime desc
```

### SQL Equivalent
```sql
SELECT trip_id, pickup_datetime, fare_amount
FROM Automotive
WHERE fare_amount > 20
ORDER BY pickup_datetime DESC
```

**Note:** In streaming scenarios, sorting applies to the current window of data

## KQL Querysets in Eventhouse

Eventhouse provides special features to enhance query development:

1. **Built-in Querysets**
   - Default queryset with sample queries
   - Syntax highlighting and autocomplete
   - Ability to create additional querysets

2. **Development Advantages**
   - Quick access to table schemas
   - Sample data previews
   - Query execution history

## Key Differences Between KQL and SQL

| Feature          | KQL (Eventhouse)                     | SQL (Traditional)               |
|------------------|--------------------------------------|---------------------------------|
| Syntax           | Pipeline-based (`|`)                | Keyword-based (SELECT/FROM)     |
| Execution Model  | Optimized for streaming              | Designed for batch queries      |
| Time Handling    | Native time-series functions         | Requires extensions             |
| Query Structure  | Left-to-right processing             | Logical statement ordering      |
| Sample Data      | `take` operator                      | `TOP`/`LIMIT` clauses           |

## Best Practices for Eventhouse Queries

1. **Start with filters** to reduce data volume early
2. **Use `project` early** to select only needed columns
3. **Leverage time-based operations** for streaming data
4. **Use querysets** to organize and save common queries
5. **Sample data first** with `take` before full queries

## Example Complex Query

```kql
Automotive
| where pickup_datetime between (ago(7d) .. now())
| summarize 
    avg_fare = avg(fare_amount),
    total_trips = count()
    by vendor_id, bin(pickup_datetime, 1d)
| sort by pickup_datetime asc
| take 1000
```

This shows KQL's strength in combining filtering, aggregation, time-binning, and sampling in a concise syntax.

---

# Filtering Rows in KQL (Eventhouse) vs. SQL

Let me explain the row filtering operations in both KQL (Eventhouse) and SQL, highlighting their similarities and differences.

## KQL (Eventhouse) Filtering Explanation

```kql
Automotive
| where fare_amount > 20
| project trip_id, pickup_datetime, fare_amount
```

### Breakdown:

1. **`Automotive`**  
   - Specifies the source table or event stream in Eventhouse

2. **`| where fare_amount > 20`**  
   - Filters the stream to only include trips with fares over $20
   - Similar to SQL's WHERE clause but uses pipe syntax
   - In Eventhouse, this filtering happens early in the stream processing pipeline

3. **`| project trip_id, pickup_datetime, fare_amount`**  
   - Selects specific columns to include in the output
   - Equivalent to SQL's SELECT column list
   - Reduces the data volume by excluding unnecessary columns early

### Eventhouse-Specific Considerations:

- **Streaming Optimization**: The filter is applied as data streams through the pipeline
- **Time-Series Focus**: Works especially well with timestamped event data
- **Late Data**: May reprocess data if late events arrive
- **Scalability**: Handles high-volume streams efficiently

## SQL Filtering Explanation

```sql
SELECT trip_id, pickup_datetime, fare_amount
FROM Automotive
WHERE fare_amount > 20
```

### Key Differences from KQL:

1. **Syntax Structure**:
   - SQL uses a declarative statement format
   - KQL uses a pipeline of operations with the `|` character

2. **Execution Model**:
   - SQL operates on stored data (batch processing)
   - KQL processes streaming data in real-time

3. **Performance**:
   - SQL may use indexes for WHERE clause optimization
   - KQL is optimized for streaming filters

## When to Use Each Approach

**Use KQL in Eventhouse when:**
- Processing real-time event streams
- You need immediate insights from live data
- Working with high-velocity time-series data

**Use SQL when:**
- Querying historical data in a data warehouse
- You need complex joins across multiple tables
- Working with structured relational data

## Advanced KQL Filtering Options

Eventhouse KQL supports additional filtering capabilities:

```kql
// Multiple conditions
| where fare_amount > 20 and trip_distance < 10

// Time-based filtering
| where pickup_datetime between (datetime(2023-01-01) .. datetime(2023-01-02))

// String matching
| where vendor_name has "Uber"

// Dynamic filtering
| where fare_amount > todouble(input_fare_threshold)

// Filtering before aggregation
| where payment_type == "Credit"
| summarize count() by vendor_id
```

## Performance Considerations

In Eventhouse:
- Apply filters as early as possible in the pipeline
- Use `where` before `project` to reduce data volume early
- Time-based filters are particularly efficient

In SQL:
- WHERE clauses can leverage indexes
- Filter conditions are evaluated during query execution
- Partition pruning can optimize time-based filters

Both approaches ultimately achieve the same goal of filtering data, but they're optimized for different data processing paradigms - KQL for streaming and SQL for batch processing.

---
# Sorting Results in KQL (Eventhouse) vs. SQL

Let me elaborate on the sorting operation in both KQL (Eventhouse) and SQL, highlighting the key differences and use cases.

## KQL (Eventhouse) Sorting Explanation

```kql
Automotive
| where fare_amount > 20
| project trip_id, pickup_datetime, fare_amount
| sort by pickup_datetime desc
```

### Breakdown:

1. **`Automotive`**  
   - This is the source table/stream in Eventhouse containing automotive trip data

2. **`| where fare_amount > 20`**  
   - Filters the stream to only include trips with fares over $20
   - Similar to SQL's `WHERE` clause

3. **`| project trip_id, pickup_datetime, fare_amount`**  
   - Selects specific columns to include in results
   - Equivalent to SQL's `SELECT` column list
   - In Eventhouse, this reduces the data volume early in the pipeline

4. **`| sort by pickup_datetime desc`**  
   - Sorts the final results by pickup time in descending order (newest first)
   - The `sort` operator is KQL's equivalent to SQL's `ORDER BY`

### Eventhouse-Specific Considerations:

- **Streaming Context**: In Eventhouse, sorting applies to the current window of streaming data
- **Performance Impact**: Sorting large streams can be resource-intensive
- **Time-Based Optimization**: Eventhouse is optimized for time-series data, so sorting by timestamp is efficient
- **Late Data Handling**: Results may change if late-arriving data enters the stream

## SQL Sorting Explanation

```sql
SELECT trip_id, pickup_datetime, fare_amount
FROM Automotive
WHERE fare_amount > 20
ORDER BY pickup_datetime DESC
```

### Key Differences from KQL:

1. **Syntax Structure**:
   - SQL uses a declarative statement structure
   - KQL uses a pipeline of operations

2. **Execution Model**:
   - SQL operates on stored data (batch processing)
   - KQL in Eventhouse processes streaming data

3. **Performance Characteristics**:
   - SQL `ORDER BY` may use indexes if available
   - KQL `sort` works on in-memory streaming data

## When to Use Each Approach

**Use KQL in Eventhouse when:**
- Processing real-time streaming data
- You need low-latency results from event streams
- Working with time-series data (like vehicle telemetry)

**Use SQL when:**
- Querying historical data in a data warehouse
- You need complex joins across multiple tables
- Working with structured business data

## Advanced KQL Sorting Options

Eventhouse KQL supports additional sorting capabilities:

```kkl
// Multi-column sort
| sort by pickup_datetime desc, fare_amount asc

// Top-N after sorting
| sort by fare_amount desc
| take 10  // Get top 10 highest fares

// Sorting within groups
| summarize trips=count() by vendor_id, bin(pickup_datetime, 1h)
| sort by vendor_id asc, pickup_datetime desc
```

Remember that in Eventhouse, sorting operations are applied to the streaming data as it flows through the pipeline, making it ideal for real-time dashboards and monitoring scenarios.

### **KQL (Kusto Query Language) Perspective in Eventhouse: Grouping & Aggregation**  

In **Microsoft Fabric Eventhouse**, KQL is used to process and analyze streaming data. The query you provided performs a **grouping and aggregation** operation, similar to SQL's `GROUP BY`. Here's the breakdown:

#### **Query Example (KQL)**
```kql
Automotive
| summarize trip_count = count() by vendor_id
| project vendor_id, trip_count
```

#### **Explanation (KQL Perspective)**
1. **`Automotive`**  
   - This is the **table** (or event stream) in Eventhouse containing automotive trip data.  
   - In Eventhouse, this could represent real-time vehicle telemetry, ride-sharing trips, or sensor data.  

2. **`| summarize trip_count = count() by vendor_id`**  
   - **`summarize`** is the KQL equivalent of SQL’s `GROUP BY` + aggregation.  
   - **`count()`** counts the number of records (trips) per `vendor_id`.  
   - **`by vendor_id`** groups the data by the vendor (e.g., Uber, Lyft, Tesla).  
   - This produces a table with `vendor_id` and `trip_count` columns.  

3. **`| project vendor_id, trip_count`**  
   - **`project`** selects only the specified columns (similar to SQL’s `SELECT`).  
   - This step is optional but improves readability by removing extra columns.  

---

### **Eventhouse-Specific Considerations**
- **Optimized for Streaming Data**  
  - Unlike batch processing (SQL), KQL in Eventhouse is optimized for **real-time analytics** on event streams.  
  - Works efficiently with **time-series data** (e.g., IoT sensors, logs, transactions).  

- **Windowing Support**  
  - If you want **time-based aggregations** (e.g., "trips per vendor per hour"), you can combine `summarize` with **windowing functions**:  
    ```kql
    Automotive
    | summarize trip_count = count() by vendor_id, bin(timestamp, 1h)
    ```
    - `bin(timestamp, 1h)` groups events into **1-hour buckets**.  

- **Integration with Eventstream Processing**  
  - If this query runs in **Eventstream’s processor**, it could feed real-time dashboards or trigger alerts (e.g., "vendor X trips dropped by 50%").  

---

### **Comparison with SQL (Eventhouse vs. Traditional DB)**
| **Feature**       | **KQL (Eventhouse)**                          | **SQL (Traditional DB)**                     |
|-------------------|----------------------------------------------|---------------------------------------------|
| **Syntax**        | Pipeline-based (`|`)                         | Keyword-based (`SELECT`, `FROM`, `GROUP BY`) |
| **Real-time**     | Optimized for streaming                      | Designed for batch queries                  |
| **Windowing**     | Built-in time-series functions (`bin()`)     | Requires explicit window functions          |
| **Use Case**      | Logs, IoT, real-time monitoring              | Business reports, transactional queries     |

---

### **Final Thoughts**
- **KQL in Eventhouse** is ideal for **real-time aggregations** on event streams.  
- The `summarize` operator is the key to **grouping and counting events** (similar to SQL `GROUP BY`).  
- For **time-based analysis**, combine with `bin()` to create temporal windows.  


### **KQL Windowing Examples in Eventhouse**  
Here are practical examples of **tumbling**, **sliding**, and **session windows** in Eventhouse using KQL, applied to a real-time automotive dataset (e.g., ride-sharing trips or IoT vehicle data).

---

### **1. Tumbling Window (Fixed Non-Overlapping Intervals)**
**Use Case**: Count trips per vendor **every 5 minutes**.  
```kql
Automotive
| where timestamp >= ago(1h)  // Analyze last 1 hour of data
| summarize trip_count = count() 
    by vendor_id, 
    bin(timestamp, 5m)  // 5-minute tumbling window
| project vendor_id, window_start = timestamp, trip_count
```
**Output**:  
| `vendor_id` | `window_start` (5m intervals) | `trip_count` |  
|-------------|-------------------------------|--------------|  
| Uber        | 2023-10-01 12:00:00           | 150          |  
| Lyft        | 2023-10-01 12:00:00           | 90           |  
| Uber        | 2023-10-01 12:05:00           | 200          |  

**Key Points**:  
- `bin(timestamp, 5m)` creates **fixed 5-minute buckets**.  
- No overlapping: Each event belongs to **only one window**.  

---

### **2. Sliding Window (Overlapping Intervals)**
**Use Case**: Alert if a vendor has **>100 trips in any 10-second window** (overlaps every 2 seconds).  
```kql
Automotive
| where timestamp >= ago(5m)  // Check last 5 minutes
| summarize trip_count = count() 
    by vendor_id, 
    window = sliding_window(timestamp, 10s, 2s)  // 10s window, sliding every 2s
| where trip_count > 100
| project vendor_id, window_start = window.start, trip_count
```
**Output** (if triggered):  
| `vendor_id` | `window_start`          | `trip_count` |  
|-------------|-------------------------|--------------|  
| Uber        | 2023-10-01 12:00:02     | 105          |  

**Key Points**:  
- `sliding_window(timestamp, window_size, slide_interval)` enables **overlapping checks**.  
- Useful for **real-time alerts** (e.g., fraud detection, spikes).  

---

### **3. Session Window (Activity-Based Grouping)**
**Use Case**: Group trips into **sessions** where gaps between trips are **<2 minutes** per driver.  
```kql
Automotive
| where timestamp >= ago(1h)
| summarize trip_count = count() 
    by driver_id, 
    session = session(timestamp, 2m)  // 2-minute inactivity gap
| project driver_id, session_start = session.start, trip_count
```
**Output**:  
| `driver_id` | `session_start`         | `trip_count` |  
|-------------|-------------------------|--------------|  
| Driver_101  | 2023-10-01 12:05:00     | 8            |  
| Driver_101  | 2023-10-01 12:20:00     | 3            | *(New session after 15m idle)* |  

**Key Points**:  
- `session(timestamp, timeout)` groups events with **gaps < timeout**.  
- Ideal for **user activity analysis** (e.g., driver shifts, app engagement).  

---

### **4. Hopping Window (Scheduled Overlapping)**
**Use Case**: Rolling count of trips **over 10-minute windows, updated every 2 minutes**.  
```kql
Automotive
| where timestamp >= ago(1h)
| summarize trip_count = count() 
    by vendor_id, 
    window = hopping_window(timestamp, 10m, 2m)  // 10m window, hop every 2m
| project vendor_id, window_start = window.start, trip_count
```
**Output**:  
| `vendor_id` | `window_start`          | `trip_count` |  
|-------------|-------------------------|--------------|  
| Uber        | 2023-10-01 12:00:00     | 500          |  
| Uber        | 2023-10-01 12:02:00     | 520          | *(Updated count with 2m overlap)* |  

**Key Points**:  
- Like sliding windows but **time-triggered** (not event-triggered).  
- Common for **dashboard refreshes** (e.g., live traffic reports).  

---

### **5. Snapshot Window (Exact Timestamp Matching)**
**Use Case**: Count trips that occurred at **exactly the same timestamp** (e.g., batch uploads).  
```kql
Automotive
| summarize trip_count = count() 
    by vendor_id, timestamp  // Group by raw timestamp
| where trip_count > 1  // Find duplicates
| project vendor_id, timestamp, trip_count
```
**Output**:  
| `vendor_id` | `timestamp`             | `trip_count` |  
|-------------|-------------------------|--------------|  
| Lyft        | 2023-10-01 12:00:00.000 | 5            | *(5 trips logged at the same millisecond)* |  

**Key Points**:  
- Rare in real-time streams but useful for **data quality checks**.  

---

### **When to Use Each Window?**
| **Window Type** | **Best For**                          | **Example**                          |
|-----------------|---------------------------------------|--------------------------------------|
| Tumbling        | Fixed reports (e.g., hourly totals)   | "Trips per vendor every 5 minutes"  |
| Sliding         | Real-time alerts                      | "Alert if >100 trips in 10 seconds" |
| Session         | User/device sessions                  | "Driver shifts with <2m gaps"       |
| Hopping         | Rolling metrics                       | "10-min trip counts, updated every 2m" |
| Snapshot        | Exact-time events                     | "Batch upload detection"            |

---

### **Bonus: Time-Based Joins**
Combine windowed aggregations with other streams:  
```kql
// Join trip counts with weather data (10m windows)
Automotive
| summarize trip_count = count() by bin(timestamp, 10m), vendor_id
| join kind=inner Weather on timestamp
| project timestamp, vendor_id, trip_count, temperature = Weather.tempC
```


> [!abstract]
> In all of the examples above, you can use either the KQL query or the equivalent SQL query to retrieve data from a table in a KQL database. There are advantages to each language and in the case of a KQL database, KQL is the preferred language for the following reasons:

- **Simplicity**: KQL is a simpler language than SQL, making it easier to learn and use.
- **Performance**: KQL is optimized for performance and can handle large amounts of data more efficiently than SQL.
- **Flexibility**: KQL is more flexible than SQL, allowing users to perform complex queries with ease.
- **Integration**: KQL is integrated with other Microsoft products, such as Azure Monitor and Azure Sentinel.

One major disadvantage of using SQL over KQL is that it's not the native language of the engine and has to go through a transformer. This language difference prevents it from being published to Power BI directly from the Queryset.

However, in some cases, SQL may be a good choice for the following reasons:

- **Compatibility**: SQL is a widely used language and is compatible with many different database systems.
- **Functionality**: SQL has a wider range of functions and features than KQL.
- **Procedural programming**: SQL supports procedural programming, which allows developers to write complex scripts and stored procedures.

## Visualizing query results in a queryset

While ultimately you may want to create real-time dashboards or Power BI reports based on your queries, it can be useful while exploring the data in a queryset to create quick data visualizations. In common with many common _notebook_ development environments, KQL querysets include the capability to render the results of a query as a chart.

![Screenshot of a visualization in a queryset.](https://learn.microsoft.com/en-us/training/wwl/query-data-kql-database-microsoft-fabric/media/queryset-visual.png)

## Using Copilot to assist with queries

For AI-based assistance with KQL querying, you can use [Copilot for Real-Time Intelligence](https://learn.microsoft.com/en-us/fabric/get-started/copilot-real-time-intelligence).

When your administrator has enabled Copilot, you see the option in queryset menu bar. Copilot opens as a pane to the side of the main query interface. When you ask a question about your data, Copilot generates the KQL code to answer your question.

![Screenshot of Copilot for Real-Time Intelligence.](https://learn.microsoft.com/en-us/training/wwl/query-data-kql-database-microsoft-fabric/media/kql-copilot.png)

---